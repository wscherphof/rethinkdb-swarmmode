#!/bin/bash

USER="$1"
NAME="$2"
TAG="$3"
ENV="$4"
if [ "$TAG" = "dev" ]; then
	ENV="dev"
fi

continue ()
{
	if [ ! "$?" = "0" ]; then
		exit $?
	fi
}

echo "* formatting source code..."
go fmt
echo "* compiling..."
# cf. https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07#.wmlq1nj3d
CGO_ENABLED=0 GOOS=linux go build -a -tags netgo -ldflags '-w' .
continue

DIR="$(pwd | awk -F "/" '{print $NF}')" # Name of current subdirectory

echo "FROM scratch" > ./Dockerfile
echo "ADD $DIR $DIR" >> ./Dockerfile
echo "EXPOSE 9090" >> ./Dockerfile
echo "ENTRYPOINT [\"/"${DIR}"\"]" >> ./Dockerfile

echo "* building image..."
if [ "$ENV" = "dev" ]; then
	# Build on all nodes, using the VirtualBox machines' automatic /Users share, enabling to skip the push to the repository.
	# Dirty, but quick.
	echo "* removing service..."
	docker-machine ssh dev-manager docker service rm ${NAME} 2>/dev/null
	for node in dev-manager dev-worker1 dev-worker2
	do
		echo "* building image on $node..."
		docker-machine ssh $node docker build -t ${USER}/${NAME}:${TAG} $PWD
	done
else
	# Build locally and use the repository to make the new image available to the nodes.
	# Prettier, but slower.
	docker build -t ${USER}/${NAME}:${TAG} .
	echo "pushing image..."
	docker push ${USER}/${NAME}:${TAG}
	continue
fi
rm ./$DIR ./Dockerfile
echo "* done"
