#!/bin/bash

ENV="$1"
USER="$2"
NAME="$3"
TAG="$4"
PORT="$5"
SOURCE="$6"
REMOTE="$7"

pushd ${SOURCE} 1>/dev/null

echo "* formatting source code..."
go fmt
echo "* compiling..."
# cf. https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07#.wmlq1nj3d
CGO_ENABLED=0 GOOS=linux go build -a -tags netgo -ldflags '-w' .
if [ "$?" != "0" ]; then
	exit $?
fi

BINARY="$(pwd | awk -F "/" '{print $NF}')" # go build names the binary after the source's subdirectory

cat > ./Dockerfile <<EOF
FROM scratch
ADD ${BINARY} ${BINARY}
EXPOSE ${PORT}
ENTRYPOINT ["/${BINARY}"]
EOF

if [ "$REMOTE" = "remote" ]; then
	# Build on all nodes, skipping the push to the repository.
	# Dirty, but quick.
	for type in worker manager
	do
		for (( i=1; ; i++ ))
		do
			node="${ENV}-${type}-${i}"
			docker-machine status $node &>/dev/null
			if [ "$?" = "0" ]; then
				echo "* building image on $node..."
				dir="$(docker-machine ssh $node pwd)"
				docker-machine scp ./${BINARY} ${node}:${dir}
				docker-machine scp ./Dockerfile ${node}:${dir}
				docker-machine ssh $node sudo docker build -t ${USER}/${NAME}:${TAG} .
			else
				break
			fi
		done
	done
else
	# Build locally and use the repository for shipping the image to the nodes.
	# Pretty, but slow.
	echo "* building image..."
	docker build -t ${USER}/${NAME}:${TAG} .
	echo "* pushing image..."
	docker push ${USER}/${NAME}:${TAG}
fi
rm ./${BINARY} ./Dockerfile

popd 1>/dev/null
