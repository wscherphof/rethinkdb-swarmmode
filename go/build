#!/bin/bash

usage ()
{
	echo
	echo "$(basename $0) formats & compiles go sources,"
	echo "and builds a Docker image to run the result"
	echo
	echo "Usage:"
	echo "  $(basename $0) [-p port ...] [-a filetoadd ...] [-A treeish] [-e env] [-t user/image:tag] sourcedir"
	echo
	echo "-t wscherphof/rethinkswarmmode:0.3 results in a Docker image with that name tag"
	echo "   leave the -t option out to only compile the go sources"
	echo "-e dev results in the image being built remotely, on each swarm node"
	echo "   leave the -e option out to get it built locally & pushed to the repository"
	echo "-p 80 -p 443 results in 'EXPOSE 80 443' in the Dockerfile"
	echo "-a file1 -a file2 results in 'ADD file1 /' and 'ADD file2 /' in the Dockerfile"
	echo "-A master results in getting the master branch of the complete sourcedir added to / in the image"
	echo
}

while getopts "t:p:e:a:A:h" opt; do
    case $opt in
        t  ) TAG="$OPTARG";;
        e  ) ENV="$OPTARG";;
        p  ) PORTS+=("$OPTARG");;
        a  ) ADDS+=("$OPTARG");;
        A  ) TREEISH="$OPTARG";;
        h  ) usage; exit;;
        \? ) echo "Unknown option: -$OPTARG" >&2; exit 1;;
        :  ) echo "Missing option argument for -$OPTARG" >&2; exit 1;;
        *  ) echo "Unimplemented option: -$OPTARG" >&2; exit 1;;
    esac
done
shift $((OPTIND -1))

pushd "$1" 1>/dev/null
if [ "$?" != "0" ]; then
	exit $?
fi

echo "* formatting source code..."
go fmt
echo "* compiling..."
# cf. https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07#.wmlq1nj3d
CGO_ENABLED=0 GOOS=linux go build -a -tags netgo -ldflags '-w' .
if [ "${TAG}" = "" -o "$?" != "0" ]; then
	exit $?
fi

BINARY="$(pwd | awk -F "/" '{print $NF}')" # go build names the binary after the source's subdirectory

echo "FROM scratch" > ./Dockerfile
echo "ADD ${BINARY} /" >> ./Dockerfile
echo "EXPOSE ${PORTS[@]}" >> ./Dockerfile
echo "ENTRYPOINT [\"/${BINARY}\"]" >> ./Dockerfile

if [ "${TREEISH}" ]; then
	echo "ADD archive.tar.gz /" >> ./Dockerfile
	git archive --format tar.gz -o archive.tar.gz ${TREEISH} .
fi

if [ "${ENV}" ]; then
	# Build on all nodes, skipping the push to the repository.
	# Dirty, but quick.
	for add in "${ADDS[@]}"; do
		echo "ADD \"$(basename ${add})\"" \"/\" >> ./Dockerfile
	done
	for type in worker manager
	do
		for (( i=1; ; i++ ))
		do
			node="${ENV}-${type}-${i}"
			docker-machine status $node &>/dev/null
			if [ "$?" = "0" ]; then
				echo "* building image on $node..."
				dir="$(docker-machine ssh $node pwd)"
				if [ "${TREEISH}" ]; then
					docker-machine scp ./archive.tar.gz ${node}:${dir}
				fi
				docker-machine scp ./${BINARY} ${node}:${dir}
				docker-machine scp ./Dockerfile ${node}:${dir}
				for add in "${ADDS[@]}"; do
					docker-machine scp "${add}" ${node}:${dir}
				done
				docker-machine ssh $node sudo docker build -t ${TAG} .
			else
				break
			fi
		done
	done
else
	# Build locally and use the repository for shipping the image to the nodes.
	# Pretty, but slow.
	for add in "${ADDS[@]}"; do
		echo "ADD \"${add}\" \"/\"" >> ./Dockerfile
	done
	echo "* building image..."
	docker build -t ${TAG} .
	echo "* pushing image..."
	docker push ${TAG}
fi
rm ./${BINARY} ./Dockerfile ./archive.tar.gz

popd 1>/dev/null
