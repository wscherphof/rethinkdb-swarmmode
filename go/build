#!/bin/bash

USER="$1"
NAME="$2"
TAG="$3"
ENV="${4=dev}"

echo "* formatting source code..."
go fmt
echo "* compiling..."
# cf. https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07#.wmlq1nj3d
CGO_ENABLED=0 GOOS=linux go build -a -tags netgo -ldflags '-w' .
if [ "$?" != "0" ]; then
	exit $?
fi

DIR="$(pwd | awk -F "/" '{print $NF}')" # Name of current subdirectory

cat >> ./Dockerfile <<EOF
FROM scratch
ADD ${DIR} ${DIR}
EXPOSE 9090
ENTRYPOINT ["/${DIR}"]
EOF

if [ "$ENV" = "dev" ]; then
	# Build on all nodes, using the VirtualBox machines' automatic /Users share, enabling to skip the push to the repository.
	# Dirty, but quick.
	for type in worker manager
	do
		for (( i=1; ; i++ ))
		do
			node="${ENV}-${type}-${i}"
			docker-machine ip $node &>/dev/null
			if [ "$?" = "0" ]; then
				echo "* building image on $node..."
				docker-machine ssh $node docker build -t ${USER}/${NAME}:${TAG} $PWD
			else
				break
			fi
		done
	done
else
	# Build locally and use the repository to make the new image available to the nodes.
	# Prettier, but slower.
	echo "* building image..."
	docker build -t ${USER}/${NAME}:${TAG} .
	echo "* pushing image..."
	docker push ${USER}/${NAME}:${TAG}
fi
rm ./$DIR ./Dockerfile
echo "* done"
